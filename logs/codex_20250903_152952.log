[2025-09-03T12:29:53] OpenAI Codex v0.28.0 (research preview)
--------
workdir: /Users/panda/Desktop/EUFM
model: gpt-5
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
--------
[2025-09-03T12:29:53] User instructions:
Create a comprehensive Strategic Agent Orchestrator system with proactive intelligence:

## Core System (src/orchestrator/):

1. **strategicOrchestrator.ts** - Main orchestrator class that:
   - Analyzes incoming tasks using NLP/keyword analysis
   - Learns from past execution patterns (stores in logs/orchestrator/)
   - Proactively suggests optimizations and alternative approaches
   - Manages resource allocation using our analytics system
   - Coordinates parallel agent execution

2. **taskAnalyzer.ts** - Intelligent task breakdown:
   - Parses natural language tasks into structured requirements
   - Identifies required capabilities (coding, research, data, web automation)
   - Estimates complexity and resource needs
   - Suggests task optimizations before execution

3. **agentFactory.ts** - Dynamic agent creation:
   - Creates specialized agents based on task requirements
   - Agent types: CodexAgent, JulesAgent, AbacusAgent, BrowserAgent, MemoryAgent
   - Handles agent lifecycle (spawn, monitor, cleanup)
   - Manages agent communication and result aggregation

4. **capabilityMapper.ts** - Tool intelligence:
   - Uses our memory system to understand tool capabilities
   - Maps tasks to optimal tool combinations
   - Considers subscription limits and costs
   - Suggests tool alternatives and optimizations

5. **executionCoordinator.ts** - Parallel execution manager:
   - Orchestrates multi-agent workflows
   - Handles dependencies between agents
   - Manages failures and fallback strategies
   - Provides real-time progress tracking

## Agent Templates (src/agents/):

6. **baseAgent.ts** - Base class for all specialized agents
7. **codexAgent.ts** - Wraps our Codex CLI for code tasks
8. **julesAgent.ts** - Google Gemini Code Assist integration
9. **abacusAgent.ts** - Abacus.AI agent with browser automation
10. **browserAgent.ts** - Web automation for tool UIs

## Intelligence Layer:

11. **patternLearner.ts** - Learns from execution history
12. **proactiveAdvisor.ts** - Suggests optimizations and improvements

## CLI Integration:

Add commands:
- orchestrator:analyze 'task description' (analyze without executing)
- orchestrator:execute 'task description' (full execution)
- orchestrator:optimize (suggest system optimizations)
- orchestrator:history (show past executions and learnings)

## Key Features:
- **Proactive**: Suggests better approaches before execution
- **Learning**: Improves from each task execution
- **Resource-aware**: Uses our analytics system for optimization
- **Parallel**: Coordinates multiple agents simultaneously
- **Resilient**: Handles failures gracefully with fallbacks
- **Cost-optimized**: Considers subscription limits and costs

Focus on making it intelligent, proactive, and deeply integrated with our existing systems (memory, analytics, Codex automation).

[2025-09-03T12:29:57] thinking

**Planning system structure**

I’m thinking about how to set up a system with multiple TypeScript files organized under `src/orchestrator` and `src/agents`, plus an intelligence layer and CLI integration with commands. I'll need to carefully consider the existing codebase to ensure everything fits well. It seems like starting with a list of files in the repository could help guide my structure and organization as I move forward. That should provide a solid foundation!
[2025-09-03T12:29:59] codex

I’m going to scan the repository to understand the current structure and where to integrate the orchestrator and CLI commands. Then I’ll scaffold the orchestrator, agents, intelligence layer, and wire up the CLI.
[2025-09-03T12:30:03] exec bash -lc 'ls -la' in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:03] bash -lc 'ls -la' succeeded in 58ms:
total 240
drwxr-xr-x   21 panda  staff    672 Sep  3 14:46 .
drwx------+  21 panda  staff    672 Sep  3 14:54 ..
-rw-r--r--@   1 panda  staff   8196 Sep  3 14:54 .DS_Store
-rw-r--r--    1 panda  staff    123 Sep  3 12:43 .env.example
drwxr-xr-x   14 panda  staff    448 Sep  3 14:57 .git
drwxr-xr-x    3 panda  staff     96 Sep  3 11:39 .github
-rw-r--r--    1 panda  staff     42 Sep  3 12:44 .gitignore
-rw-r--r--    1 panda  staff   5088 Sep  3 14:08 CODE_OF_CONDUCT.md
-rw-r--r--@   1 panda  staff    458 Sep  3 11:40 CONTRIBUTING.md
-rw-r--r--    1 panda  staff   7894 Sep  3 14:46 PROJECT_OVERVIEW.md
-rw-r--r--@   1 panda  staff    313 Sep  3 14:48 README.md
-rw-r--r--@   1 panda  staff    425 Sep  3 11:40 SECURITY.md
drwxr-xr-x    8 panda  staff    256 Sep  3 15:05 dist
drwxr-xr-x   11 panda  staff    352 Sep  3 15:01 docs
drwxr-xr-x   11 panda  staff    352 Sep  3 15:29 logs
drwxr-xr-x  113 panda  staff   3616 Sep  3 12:43 node_modules
-rw-r--r--    1 panda  staff  64979 Sep  3 12:43 package-lock.json
-rw-r--r--    1 panda  staff    481 Sep  3 12:42 package.json
drwxr-xr-x    3 panda  staff     96 Sep  3 14:31 scripts
[2025-09-03T12:30:03] tokens used: 859
[2025-09-03T12:30:07] exec bash -lc "ls -la src && rg --files src | sed -n '1,200p'" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:07] bash -lc "ls -la src && rg --files src | sed -n '1,200p'" succeeded in 113ms:
total 16
drwxr-xr-x   8 panda  staff   256 Sep  3 14:58 .
drwxr-xr-x  21 panda  staff   672 Sep  3 14:46 ..
-rw-r--r--@  1 panda  staff  6148 Sep  3 12:43 .DS_Store
drwxr-xr-x   5 panda  staff   160 Sep  3 12:43 adapters
drwxr-xr-x   7 panda  staff   224 Sep  3 15:12 analytics
drwxr-xr-x   3 panda  staff    96 Sep  3 12:42 cli
drwxr-xr-x   4 panda  staff   128 Sep  3 14:48 memory
drwxr-xr-x   4 panda  staff   128 Sep  3 13:10 tools
src/analytics/optimizationEngine.ts
src/analytics/autoTracker.ts
src/analytics/usageAnalytics.ts
src/analytics/subscriptionManager.ts
src/analytics/toolUsageTracker.ts
src/adapters/openai.ts
src/adapters/google_gemini.ts
src/adapters/anthropic.ts
src/cli/index.ts
src/memory/index.ts
src/memory/memoryLoader.ts
[2025-09-03T12:30:07] tokens used: 771

[2025-09-03T12:30:09] thinking

**Exploring integration possibilities**

I notice we have analytics and memory subsystems, as well as adapters for models, plus the CLI index.ts. It seems like we need to integrate with "Codex automation," probably through this CLI. The dist folder is present, so I'll open those files to check their APIs. It's essential to understand how they work to move forward with the integration effectively. I'll take a closer look at those files now!
[2025-09-03T12:30:12] exec bash -lc "sed -n '1,200p' src/analytics/optimizationEngine.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:12] bash -lc "sed -n '1,200p' src/analytics/optimizationEngine.ts" succeeded in 44ms:
import { PlanDefinition, PlanId, Provider, SubscriptionManager } from './subscriptionManager.js';
import { DEFAULT_PRICING, ToolUsageTracker, UsageEvent, UsageSnapshot, round2 } from './toolUsageTracker.js';

export interface OptimizationSuggestion {
  id: string;
  title: string;
  impact: 'low' | 'medium' | 'high';
  details: string;
  action?: string;
}

export interface OptimizationReport {
  period: { from: string; to: string };
  subscriptions: Record<Provider, PlanDefinition>;
  totals: UsageSnapshot['totals'];
  estCostUSD: number;
  suggestions: OptimizationSuggestion[];
  approachingLimits: Array<{ provider: Provider; plan: PlanId; metric: string; used: number; limit: number; note?: string }>;
}

[2025-09-03T12:30:12] tokens used: 514
[2025-09-03T12:30:15] exec bash -lc "sed -n '1,200p' src/analytics/subscriptionManager.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:15] bash -lc "sed -n '1,200p' src/analytics/subscriptionManager.ts" succeeded in 42ms:
import fetch from 'node-fetch';

export type Provider = 'chatgpt' | 'claude' | 'perplexity' | 'abacus';

export type PlanId =
  | 'chatgpt_free'
  | 'chatgpt_plus'
  | 'claude_free'
  | 'claude_pro'
  | 'perplexity_free'
  | 'perplexity_pro'
  | 'abacus_free'
  | 'abacus_pro'
  | 'abacus_enterprise';

export interface PlanFeature {
  name: string;
  description?: string;
}

[2025-09-03T12:30:15] tokens used: 1671
[2025-09-03T12:30:18] exec bash -lc "sed -n '1,200p' src/analytics/toolUsageTracker.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:18] bash -lc "sed -n '1,200p' src/analytics/toolUsageTracker.ts" succeeded in 87ms:
import { promises as fs } from 'fs';
import path from 'path';
import { PlanId, Provider } from './subscriptionManager.js';

export type UsageMetric = 'messages' | 'requests' | 'tokens' | 'images';

export interface UsageEvent {
  id: string;
  ts: string; // ISO date
  provider: Provider;
  plan: PlanId;
  metric: UsageMetric;
  amount: number; // e.g., 1 request, 5234 tokens, etc.
  costUSD?: number; // optional per-event cost, if known
  model?: string;
  tags?: string[];
  notes?: string;
}

export interface UsageSnapshot {
[2025-09-03T12:30:18] tokens used: 2352
[2025-09-03T12:30:21] exec bash -lc "sed -n '1,200p' src/memory/index.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:21] bash -lc "sed -n '1,200p' src/memory/index.ts" succeeded in 42ms:
export * from './memoryLoader';

[2025-09-03T12:30:21] tokens used: 1555
[2025-09-03T12:30:24] exec bash -lc "sed -n '1,200p' src/memory/memoryLoader.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:24] bash -lc "sed -n '1,200p' src/memory/memoryLoader.ts" succeeded in 40ms:
import { promises as fs } from 'node:fs';
import path from 'node:path';

export interface Note {
  path: string;
  title: string;
  content: string;
  headings: string[];
  links: string[];
}

function isMarkdown(filePath: string): boolean {
  return filePath.toLowerCase().endsWith('.md');
}

async function walk(dir: string, ignoreDirs: Set<string>): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files: string[] = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
[2025-09-03T12:30:24] tokens used: 220
[2025-09-03T12:30:26] exec bash -lc "sed -n '1,200p' src/cli/index.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:26] bash -lc "sed -n '1,200p' src/cli/index.ts" succeeded in 69ms:
#!/usr/bin/env node
import { runPerplexityTest } from '../tools/perplexity_sonar.js';
import { runGeminiTest } from '../tools/gemini_test.js';
import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';

async function main() {
	const cmd = process.argv[2] || 'help';
		switch (cmd) {
		case 'analytics:setup': {
			const agent = new UsageAnalyticsAgent();
			await agent.interactiveSetup();
			const limits = await agent.fetchLimits();
			console.log('\nFetched plan info (best-effort):');
			for (const l of limits) {
				console.log(`  ${l.provider}: ${l.plan} from ${l.source}${l.rawSourceUrl ? ` (${l.rawSourceUrl})` : ''}`);
			}
			break;
		}

[2025-09-03T12:30:26] tokens used: 1387
[2025-09-03T12:30:30] exec bash -lc "sed -n '1,240p' src/analytics/usageAnalytics.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:30] bash -lc "sed -n '1,240p' src/analytics/usageAnalytics.ts" succeeded in 28ms:
import readline from 'readline';
import { FileSubscriptionStore, LimitsFetchResult, PlanDefinition, PLAN_CATALOG, PlanId, Provider, SubscriptionManager, UserSubscriptions } from './subscriptionManager.js';
import { ToolUsageTracker, UsageEvent } from './toolUsageTracker.js';
import { OptimizationEngine } from './optimizationEngine.js';

function rlQuestion(rl: readline.Interface, q: string): Promise<string> {
  return new Promise((resolve) => rl.question(q, resolve));
}

export class UsageAnalyticsAgent {
  subs: SubscriptionManager;
  tracker: ToolUsageTracker;
  engine: OptimizationEngine;

  constructor(private baseDir = 'logs/analytics') {
    this.subs = new SubscriptionManager(new FileSubscriptionStore(`${baseDir}/subscriptions.json`));
    this.tracker = new ToolUsageTracker(baseDir);
    this.engine = new OptimizationEngine(this.subs, this.tracker);
  }

[2025-09-03T12:30:30] tokens used: 1139

[2025-09-03T12:30:33] thinking

**Planning analytics integration**

I'm thinking about the existing analytics modules and memory loader along with the CLI. I need to add the orchestrator and integrate commands like analyze, execute, optimize, and history. Additionally, I was considering creating a logs/orchestrator directory for storing histories. It's crucial to ensure the tsconfig and package dependencies are in order. The next step would be to open the package.json for that.
[2025-09-03T12:30:36] exec bash -lc 'cat package.json' in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:36] bash -lc 'cat package.json' succeeded in 116ms:
{
  "name": "eufm",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc -p .",
    "start": "node dist/cli/index.js",
    "dev": "tsx src/cli/index.ts",
    "lint": "eslint .",
    "typecheck": "tsc -p tsconfig.json --noEmit"
  },
  "dependencies": {
    "node-fetch": "^3.3.2",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/node": "^20.12.7",
    "eslint": "^8.57.0",
    "tsx": "^4.16.2",
[2025-09-03T12:30:36] tokens used: 1953

[2025-09-03T12:30:45] thinking

**Planning interface and integration**

I'm thinking about creating some basic interfaces like Task, AnalyzedTask, AgentResult, and OrchestrationResult. I should also integrate with analytics to provide resource-aware and cost-optimized suggestions. The OptimizationEngine will help propose suggestions based on usage, which sounds essential. For agent implementations, I'll make sure to integrate with the existing adapters like openai.ts, google_gemini.ts, and anthropic.ts. Let's take a look at those. They could be crucial for my plans!
[2025-09-03T12:30:48] exec bash -lc "sed -n '1,200p' src/adapters/openai.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:48] bash -lc "sed -n '1,200p' src/adapters/openai.ts" succeeded in 32ms:
export interface CompleteOptions {
	model: string;
	temperature?: number;
	maxOutputTokens?: number;
	json?: boolean;
}

export async function openaiComplete(prompt: string, options: CompleteOptions): Promise<string> {
	const apiKey = process.env.OPENAI_API_KEY;
	if (!apiKey) throw new Error('Missing OPENAI_API_KEY');
	const url = 'https://api.openai.com/v1/chat/completions';
	const body: any = {
		model: options.model,
		messages: [
			{ role: 'system', content: 'You are EUFM OpenAI adapter.' },
			{ role: 'user', content: prompt }
		],
		temperature: options.temperature ?? 0.2
	};
	if (options.json) body.response_format = { type: 'json_object' };
[2025-09-03T12:30:48] tokens used: 696
[2025-09-03T12:30:52] exec bash -lc "sed -n '1,200p' src/adapters/google_gemini.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:52] bash -lc "sed -n '1,200p' src/adapters/google_gemini.ts" succeeded in 67ms:
import fetch from 'node-fetch';
import { trackLLMUsage } from '../analytics/autoTracker.js';

export async function geminiComplete(prompt: string, model = 'gemini-1.5-pro'): Promise<string> {
	const apiKey = process.env.GEMINI_API_KEY;
	if (!apiKey) throw new Error('Missing GEMINI_API_KEY');
	const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
	const res = await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
	});
	if (!res.ok) throw new Error(`Gemini error ${res.status}: ${await res.text()}`);
	const data: any = await res.json();
	const text = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? '';

	// Record usage (optional, best-effort)
	try { await trackLLMUsage('gemini', model, prompt, text); } catch {}
	return text;
}
[2025-09-03T12:30:52] tokens used: 512
[2025-09-03T12:30:56] exec bash -lc "sed -n '1,200p' src/adapters/anthropic.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:56] bash -lc "sed -n '1,200p' src/adapters/anthropic.ts" succeeded in 108ms:
import fetch from 'node-fetch';

export async function anthropicComplete(prompt: string, model = 'claude-3-5-sonnet-latest'): Promise<string> {
	const apiKey = process.env.ANTHROPIC_API_KEY;
	if (!apiKey) throw new Error('Missing ANTHROPIC_API_KEY');
	const url = 'https://api.anthropic.com/v1/messages';
	const res = await fetch(url, {
		method: 'POST',
		headers: {
			'content-type': 'application/json',
			'x-api-key': apiKey,
			'anthropic-version': '2023-06-01'
		},
		body: JSON.stringify({
			model,
			max_tokens: 1024,
			messages: [
				{ role: 'user', content: prompt }
			]
		})
[2025-09-03T12:30:56] tokens used: 470
[2025-09-03T12:30:59] exec bash -lc "sed -n '1,200p' src/tools/perplexity_sonar.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:30:59] bash -lc "sed -n '1,200p' src/tools/perplexity_sonar.ts" succeeded in 90ms:
import fetch from 'node-fetch';
import { trackLLMUsage } from '../analytics/autoTracker.js';

const ENDPOINT = 'https://api.perplexity.ai/chat/completions';

export async function runPerplexityTest(prompt: string): Promise<string> {
	const apiKey = process.env.PERPLEXITY_API_KEY;
	if (!apiKey) throw new Error('Missing PERPLEXITY_API_KEY');

	const model = process.env.PERPLEXITY_MODEL || 'sonar-pro';
	const body = {
		model,
		messages: [
			{ role: 'system', content: 'You are EUFM test agent.' },
			{ role: 'user', content: prompt }
		],
		temperature: 0.2
	};

	const res = await fetch(ENDPOINT, {
[2025-09-03T12:30:59] tokens used: 438
[2025-09-03T12:31:02] exec bash -lc "sed -n '1,200p' src/analytics/autoTracker.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:31:02] bash -lc "sed -n '1,200p' src/analytics/autoTracker.ts" succeeded in 97ms:
// Simple, optional usage auto-tracker for LLM calls
// - Enabled only when EUFM_TRACK_USAGE=true
// - Records requests and tokens using UsageAnalyticsAgent
// - Estimates tokens when API does not provide usage
// - Never throws: failures are swallowed to avoid impacting API calls

import { UsageAnalyticsAgent } from './usageAnalytics.js';

let agentSingleton: UsageAnalyticsAgent | null = null;

function getAgent(): UsageAnalyticsAgent {
  if (!agentSingleton) agentSingleton = new UsageAnalyticsAgent();
  return agentSingleton;
}

function isEnabled(): boolean {
  return String(process.env.EUFM_TRACK_USAGE || '').toLowerCase() === 'true';
}

export function estimateTokens(text: string | undefined | null): number {
[2025-09-03T12:31:02] tokens used: 563

[2025-09-03T12:31:16] thinking

**Implementing modifications**

I need to modify `src/cli/index.ts` to add new commands. It's a straightforward process, but I also need to take care of integrating new imports. I’ll ensure that everything aligns correctly with existing code, and verify that the commands function as intended once they're implemented. It’s crucial to keep everything organized as I make these changes, so no unexpected issues arise later on! Let's get started on this.
[2025-09-03T12:31:18] codex

I’m going to scaffold the orchestrator, agents, intelligence layer, and wire new CLI commands, integrating with existing memory and analytics modules. Then I’ll add lightweight, dependency-free implementations that log to logs/orchestrator and run end-to-end.
[2025-09-03T12:31:35] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/orchestrator/types.ts
export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';

export interface TaskRequirement {
  id: string;
  description: string;
  capabilities: Capability[];
  dependencies?: string[];
  priority?: number;
  estimatedComplexity: 'low' | 'medium' | 'high';
  estimatedResources: {
    timeMinutes: number;
    tokens?: number;
    concurrency?: number;
  };
  optimizations?: string[];
}

export interface AnalyzedTask {
  taskId: string;
  title: string;
  original: string;
  requirements: TaskRequirement[];
  riskLevel: 'low' | 'medium' | 'high';
  notes?: string[];
}

export interface AgentSpec {
  id: string;
  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
  requirementId: string;
  capabilities: Capability[];
  params?: Record<string, any>;
}

export interface AgentResult {
  agentId: string;
  requirementId: string;
  success: boolean;
  output: string;
  artifacts?: Record<string, any>;
  costUSD?: number;
  startedAt: string;
  finishedAt: string;
  retries?: number;
  error?: string;
}

export interface OrchestrationPlan {
  task: AnalyzedTask;
  agentSpecs: AgentSpec[];
  parallelBatches: string[][]; // batches of requirementIds to run in parallel
  suggestions: string[];
}

export interface OrchestrationResult {
  taskId: string;
  startedAt: string;
  finishedAt: string;
  plan: OrchestrationPlan;
  results: AgentResult[];
  success: boolean;
  summary: string;
}

[2025-09-03T12:31:35] apply_patch(auto_approved=true) exited 0 in 179ms:
Success. Updated the following files:
A src/orchestrator/types.ts
[2025-09-03T12:31:35] turn diff:
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:31:35] tokens used: 1713
[2025-09-03T12:31:35] turn diff:
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:09] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/orchestrator/taskAnalyzer.ts
import { loadKnowledgeBase } from '../memory/memoryLoader.js';
import { AnalyzedTask, Capability, TaskRequirement } from './types.js';

function detectCapabilities(text: string): Capability[] {
  const t = text.toLowerCase();
  const caps = new Set<Capability>();
  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
  // Defaults: if nothing matched, infer based on verbs
  if (caps.size === 0) caps.add('research');
  return Array.from(caps);
}

function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
  const len = text.length;
  const signals = [
    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
    /(deadline|mission[- ]critical|production)/i,
    /(integrate|refactor|migrate|optimi[sz]e)/i,
  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
  if (signals >= 2 || len > 800) return 'high';
  if (signals >= 1 || len > 300) return 'medium';
  return 'low';
}

function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
  return { timeMinutes: base, tokens, concurrency };
}

function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
  // Heuristic split by sentences and capabilities; in practice this would use a model.
  const sentences = text
    .split(/\n+|(?<=[.!?])\s+/)
    .map((s) => s.trim())
    .filter(Boolean);
  const reqs: TaskRequirement[] = [];
  let idx = 0;
  for (const s of sentences) {
    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
    if (!caps.length) continue;
    const complexity = estimateComplexity(s);
    reqs.push({
      id: `req_${++idx}`,
      description: s,
      capabilities: caps,
      estimatedComplexity: complexity,
      estimatedResources: estimateResources(caps, complexity),
      dependencies: [],
      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
      optimizations: [],
    });
  }
  if (reqs.length === 0) {
    const complexity = estimateComplexity(text);
    reqs.push({
      id: `req_1`,
      description: text,
      capabilities,
      estimatedComplexity: complexity,
      estimatedResources: estimateResources(capabilities, complexity),
      dependencies: [],
      priority: 2,
      optimizations: [],
    });
  }
  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
  if (firstIdx > 0) {
    const [first] = reqs.splice(firstIdx, 1);
    reqs.unshift(first);
    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
  }
  return reqs;
}

export class TaskAnalyzer {
  async analyze(taskText: string): Promise<AnalyzedTask> {
    const title = taskText.split(/\n/)[0].slice(0, 80);
    const caps = detectCapabilities(taskText);
    const complexity = estimateComplexity(taskText);
    const notes: string[] = [];

    // Use knowledge base to suggest potential links or existing context
    try {
      const kb = await loadKnowledgeBase();
      const related = kb.filter((n) => {
        const q = title.toLowerCase();
        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
      });
      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
    } catch {}

    const requirements = splitIntoRequirements(taskText, caps);

    // Pre-execution optimizations
    for (const r of requirements) {
      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
    }

    return {
      taskId: `task_${Date.now()}`,
      title,
      original: taskText,
      requirements,
      riskLevel: complexity,
      notes,
    };
  }
}

[2025-09-03T12:32:10] apply_patch(auto_approved=true) exited 0 in 562ms:
Success. Updated the following files:
A src/orchestrator/taskAnalyzer.ts
[2025-09-03T12:32:10] turn diff:
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:10] tokens used: 2260
[2025-09-03T12:32:10] turn diff:
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:29] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/orchestrator/capabilityMapper.ts
import { loadKnowledgeBase } from '../memory/memoryLoader.js';
import { OptimizationEngine } from '../analytics/optimizationEngine.js';
import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
import { AgentSpec } from './types.js';

export class CapabilityMapper {
  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
  tracker = new ToolUsageTracker();
  engine = new OptimizationEngine(this.subs, this.tracker);

  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
    const specs: AgentSpec[] = [];
    const caps = new Set(capabilities);
    const subs = await this.subs.getSubscriptions();

    // Memory-aware routing
    try {
      const kb = await loadKnowledgeBase();
      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
      if (isDocHeavy) {
        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
      }
    } catch {}

    // Coding
    if (caps.has('coding')) {
      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
      // Secondary advisor using Gemini for code review if available
      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
    }

    // Research
    if (caps.has('research')) {
      // Prefer Perplexity for web research if PRO plan
      const usePerplexity = subs.perplexity === 'perplexity_pro';
      if (usePerplexity) {
        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
      } else {
        // Fall back to Gemini/Claude via JulesAgent for general research
        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
      }
    }

    // Data
    if (caps.has('data')) {
      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
    }

    // Web automation
    if (caps.has('web_automation')) {
      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
    }

    return specs;
  }
}

[2025-09-03T12:32:29] apply_patch(auto_approved=true) exited 0 in 755ms:
Success. Updated the following files:
A src/orchestrator/capabilityMapper.ts
[2025-09-03T12:32:29] turn diff:
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:29] tokens used: 18003
[2025-09-03T12:32:29] turn diff:
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:35] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/agents/baseAgent.ts
import { AgentResult } from '../orchestrator/types.js';

export interface AgentContext {
  workingDir?: string;
  shared?: Record<string, any>;
}

export interface AgentRunOptions {
  input: string;
  timeoutMs?: number;
  dryRun?: boolean;
}

export abstract class BaseAgent {
  constructor(public id: string, public requirementId: string) {}

  abstract get type(): string;
  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;

  protected now() { return new Date().toISOString(); }
}

[2025-09-03T12:32:36] apply_patch(auto_approved=true) exited 0 in 956ms:
Success. Updated the following files:
A src/agents/baseAgent.ts
[2025-09-03T12:32:36] turn diff:
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:36] tokens used: 2761
[2025-09-03T12:32:36] turn diff:
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:57] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/agents/codexAgent.ts
import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
import { AgentResult } from '../orchestrator/types.js';
import { openaiComplete } from '../adapters/openai.js';
import { anthropicComplete } from '../adapters/anthropic.js';
import { geminiComplete } from '../adapters/google_gemini.js';

function pickModel(pref: 'balanced' | 'cost' | 'quality') {
  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
  return { provider: 'openai', model: 'gpt-4o' } as const;
}

export class CodexAgent extends BaseAgent {
  get type() { return 'CodexAgent'; }

  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
    const startedAt = this.now();
    try {
      if (opts.dryRun) {
        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
      }
      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
      const { provider, model } = pickModel(pref);
      let out = '';
      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
      else out = await geminiComplete(prompt, 'gemini-1.5-pro');

      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
    } catch (e: any) {
      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
    }
  }
}

[2025-09-03T12:32:58] apply_patch(auto_approved=true) exited 0 in 1.05s:
Success. Updated the following files:
A src/agents/codexAgent.ts
[2025-09-03T12:32:58] turn diff:
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:32:58] tokens used: 889
[2025-09-03T12:32:58] turn diff:
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:04] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/agents/julesAgent.ts
import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
import { AgentResult } from '../orchestrator/types.js';
import { geminiComplete } from '../adapters/google_gemini.js';

export class JulesAgent extends BaseAgent {
  get type() { return 'JulesAgent'; }
  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
    const startedAt = this.now();
    try {
      if (opts.dryRun) {
        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
      }
      const role = ctx?.shared?.role || 'review';
      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
    } catch (e: any) {
      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
    }
  }
}

[2025-09-03T12:33:05] apply_patch(auto_approved=true) exited 0 in 1.31s:
Success. Updated the following files:
A src/agents/julesAgent.ts
[2025-09-03T12:33:05] turn diff:
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:05] tokens used: 1208
[2025-09-03T12:33:05] turn diff:
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:20] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/agents/abacusAgent.ts
import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
import { AgentResult } from '../orchestrator/types.js';
import { runPerplexityTest } from '../tools/perplexity_sonar.js';

export class AbacusAgent extends BaseAgent {
  get type() { return 'AbacusAgent'; }
  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
    const startedAt = this.now();
    try {
      if (opts.dryRun) {
        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
      }
      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
    } catch (e: any) {
      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
    }
  }
}

[2025-09-03T12:33:21] apply_patch(auto_approved=true) exited 0 in 1.47s:
Success. Updated the following files:
A src/agents/abacusAgent.ts
[2025-09-03T12:33:21] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:21] tokens used: 844
[2025-09-03T12:33:21] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:38] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/agents/browserAgent.ts
import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
import { AgentResult } from '../orchestrator/types.js';

export class BrowserAgent extends BaseAgent {
  get type() { return 'BrowserAgent'; }
  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
    const startedAt = this.now();
    try {
      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
      const plan = [
        'Open target tool UI',
        'Authenticate if needed',
        'Navigate to required section',
        'Perform batch actions to minimize navigation',
        'Export results and store artifact',
      ];
      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
    } catch (e: any) {
      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
    }
  }
}

[2025-09-03T12:33:40] apply_patch(auto_approved=true) exited 0 in 1.43s:
Success. Updated the following files:
A src/agents/browserAgent.ts
[2025-09-03T12:33:40] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:40] tokens used: 864
[2025-09-03T12:33:40] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:49] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/agents/memoryAgent.ts
import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
import { AgentResult } from '../orchestrator/types.js';
import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';

export class MemoryAgent extends BaseAgent {
  get type() { return 'MemoryAgent'; }
  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
    const startedAt = this.now();
    try {
      const notes = await loadKnowledgeBase();
      const results = findNotesByQuery(notes, opts.input);
      const context = toContext(results, { maxBytes: 8000 });
      const output = results.length
        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
        : 'No direct matches in knowledge base.';
      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
    } catch (e: any) {
      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
    }
  }
}

[2025-09-03T12:33:52] apply_patch(auto_approved=true) exited 0 in 2.62s:
Success. Updated the following files:
A src/agents/memoryAgent.ts
[2025-09-03T12:33:52] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:33:52] tokens used: 903
[2025-09-03T12:33:52] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:00] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/orchestrator/agentFactory.ts
import { AgentSpec } from './types.js';
import { BaseAgent } from '../agents/baseAgent.js';
import { CodexAgent } from '../agents/codexAgent.js';
import { JulesAgent } from '../agents/julesAgent.js';
import { AbacusAgent } from '../agents/abacusAgent.js';
import { BrowserAgent } from '../agents/browserAgent.js';
import { MemoryAgent } from '../agents/memoryAgent.js';

export class AgentFactory {
  create(spec: AgentSpec): BaseAgent {
    const { id, type, requirementId } = spec;
    switch (type) {
      case 'CodexAgent': return new CodexAgent(id, requirementId);
      case 'JulesAgent': return new JulesAgent(id, requirementId);
      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
      default:
        throw new Error(`Unknown agent type: ${type}`);
    }
  }
}

[2025-09-03T12:34:01] apply_patch(auto_approved=true) exited 0 in 1.72s:
Success. Updated the following files:
A src/orchestrator/agentFactory.ts
[2025-09-03T12:34:01] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:01] tokens used: 751
[2025-09-03T12:34:01] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:11] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/orchestrator/executionCoordinator.ts
import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
import { AgentFactory } from './agentFactory.js';

export interface ExecutionOptions {
  dryRun?: boolean;
  timeoutMs?: number;
  concurrency?: number; // max agents in parallel
}

export class ExecutionCoordinator {
  private factory = new AgentFactory();

  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
    const results: AgentResult[] = [];
    const ctxShared: Record<string, any> = {};
    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);

    for (const batch of plan.parallelBatches) {
      // Throttle within batch to configured concurrency
      const queue = [...batch];
      const active: Promise<void>[] = [];
      const runOne = async (reqId: string) => {
        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
        for (const spec of specs) {
          const agent = this.factory.create(spec);
          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
          results.push(out);
          // Simple knowledge sharing: stash outputs by requirement
          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
          if (!out.success) break; // leave early if agent in this requirement failed
        }
      };

      while (queue.length > 0 || active.length > 0) {
        while (active.length < concurrency && queue.length > 0) {
          const reqId = queue.shift()!;
          const p = runOne(reqId).finally(() => {
            const i = active.indexOf(p as any);
            if (i >= 0) active.splice(i, 1);
          });
          active.push(p as any);
        }
        await Promise.race(active).catch(() => {});
      }
    }

    return results;
  }
}

[2025-09-03T12:34:13] apply_patch(auto_approved=true) exited 0 in 1.81s:
Success. Updated the following files:
A src/orchestrator/executionCoordinator.ts
[2025-09-03T12:34:13] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:13] tokens used: 1010
[2025-09-03T12:34:13] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:34] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/intelligence/patternLearner.ts
import { promises as fs } from 'fs';
import path from 'path';
import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';

export interface LearnedPattern {
  id: string;
  description: string;
  signals: string[];
  effectiveness: number; // 0..1
  lastUpdated: string;
}

export class PatternLearner {
  constructor(private baseDir = 'logs/orchestrator') {}

  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }

  private async load(): Promise<LearnedPattern[]> {
    try {
      const txt = await fs.readFile(this.patternsPath(), 'utf8');
      const arr = JSON.parse(txt);
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }

  private async save(all: LearnedPattern[]) {
    await fs.mkdir(this.baseDir, { recursive: true });
    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
  }

  async updateFromRun(run: OrchestrationResult): Promise<void> {
    const all = await this.load();
    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
    for (const r of run.results) {
      const key = `${r.requirementId}`;
      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
      groups[key].total += 1;
      if (r.success) groups[key].success += 1;
      // derive signals from content
      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
    }
    const now = new Date().toISOString();
    for (const [key, g] of Object.entries(groups)) {
      const eff = g.total ? g.success / g.total : 0;
      const existing = all.find((p) => p.id === key);
      if (existing) {
        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
        existing.lastUpdated = now;
      } else {
        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
      }
    }
    await this.save(all);
  }

  async list(): Promise<LearnedPattern[]> { return this.load(); }
}

[2025-09-03T12:34:36] apply_patch(auto_approved=true) exited 0 in 1.87s:
Success. Updated the following files:
A src/intelligence/patternLearner.ts
[2025-09-03T12:34:36] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:36] tokens used: 1491
[2025-09-03T12:34:36] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:45] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/intelligence/proactiveAdvisor.ts
import { OptimizationEngine } from '../analytics/optimizationEngine.js';
import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
import { LearnedPattern, PatternLearner } from './patternLearner.js';

export interface AdvisoryReport {
  systemSuggestions: string[];
  learnedPatterns: LearnedPattern[];
}

export class ProactiveAdvisor {
  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
  tracker = new ToolUsageTracker();
  engine = new OptimizationEngine(this.subs, this.tracker);
  learner = new PatternLearner();

  async advise(): Promise<AdvisoryReport> {
    const events = await this.tracker.list();
    const report = await this.engine.buildReport(events);
    const learned = await this.learner.list();
    const sys: string[] = [];

    // Convert optimization suggestions to simple text advice
    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);

    // Meta-suggestions based on learned patterns
    for (const p of learned) {
      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
    }

    // De-duplicate
    const deduped = Array.from(new Set(sys));
    return { systemSuggestions: deduped, learnedPatterns: learned };
  }
}

[2025-09-03T12:34:48] apply_patch(auto_approved=true) exited 0 in 2.74s:
Success. Updated the following files:
A src/intelligence/proactiveAdvisor.ts
[2025-09-03T12:34:48] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:34:48] tokens used: 1405
[2025-09-03T12:34:48] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:35:22] apply_patch auto_approved=true:
A /Users/panda/Desktop/EUFM/src/orchestrator/strategicOrchestrator.ts
import { promises as fs } from 'fs';
import path from 'path';
import { TaskAnalyzer } from './taskAnalyzer.js';
import { CapabilityMapper } from './capabilityMapper.js';
import { ExecutionCoordinator } from './executionCoordinator.js';
import { PatternLearner } from '../intelligence/patternLearner.js';
import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';

export class StrategicOrchestrator {
  private analyzer = new TaskAnalyzer();
  private mapper = new CapabilityMapper();
  private coordinator = new ExecutionCoordinator();
  private learner = new PatternLearner();
  private advisor = new ProactiveAdvisor();
  private baseDir = 'logs/orchestrator';

  private async saveJson(rel: string, data: any) {
    const out = path.join(this.baseDir, rel);
    await fs.mkdir(path.dirname(out), { recursive: true });
    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
  }

  private async listRuns(): Promise<string[]> {
    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
  }

  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
    const analyzed = await this.analyzer.analyze(task);
    const suggestions: string[] = [];
    // Proactive advice
    try {
      const adv = await this.advisor.advise();
      suggestions.push(...adv.systemSuggestions);
    } catch {}
    // Requirement-level suggestions
    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
  }

  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
    const agentSpecs = (
      await Promise.all(
        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
      )
    ).flat();
    // batch by simple dependency: requirements with no deps in batch 1, etc.
    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
    const remaining = new Set(analyzed.requirements.map((r) => r.id));
    const batches: string[][] = [];
    while (remaining.size) {
      const ready: string[] = [];
      for (const id of Array.from(remaining)) {
        const deps = idToDeps.get(id)!;
        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
      }
      if (ready.length === 0) { // break circular deps
        ready.push(...Array.from(remaining));
      }
      batches.push(ready);
      ready.forEach((r) => remaining.delete(r));
    }
    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
  }

  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
    const startedAt = new Date().toISOString();
    const { analyzed } = await this.analyze(taskText);
    const plan = await this.plan(analyzed);
    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
    const success = results.every((r) => r.success);
    const finishedAt = new Date().toISOString();
    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };

    await this.saveJson(`run_${plan.task.taskId}.json`, run);
    await this.learner.updateFromRun(run).catch(() => {});
    return run;
  }

  async optimize(): Promise<string[]> {
    const adv = await this.advisor.advise();
    return adv.systemSuggestions;
  }

  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
    const files = (await this.listRuns()).sort();
    let latest: OrchestrationResult | undefined;
    if (files.length) {
      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
      latest = JSON.parse(txt);
    }
    return { files, latest };
  }
}

[2025-09-03T12:35:25] apply_patch(auto_approved=true) exited 0 in 2.61s:
Success. Updated the following files:
A src/orchestrator/strategicOrchestrator.ts
[2025-09-03T12:35:25] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:35:25] tokens used: 1850
[2025-09-03T12:35:25] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:35:44] apply_patch auto_approved=true:
M /Users/panda/Desktop/EUFM/src/cli/index.ts
@@ -5,2 +5,3 @@
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
@@ -79,2 +80,61 @@
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
@@ -86,2 +146,6 @@
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
[2025-09-03T12:35:48] apply_patch(auto_approved=true) exited 0 in 3.35s:
Success. Updated the following files:
M src/cli/index.ts
[2025-09-03T12:35:48] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:35:48] tokens used: 2767
[2025-09-03T12:35:48] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+


[2025-09-03T12:35:53] thinking

**Verifying TypeScript imports**

I need to confirm that our TypeScript imports are using the correct .js extensions since we're utilizing type: module and the tsconfig likely compiles with ES modules. I've noticed that our current files do that. For new imports from '../orchestrator/...', we should follow suit. It looks like taskAnalyzer.ts handles .js imports correctly, but types.ts doesn't include any. However, the rest seem to be using .js as intended. I'll check src/tools/gemini_test.ts next.
[2025-09-03T12:35:57] exec bash -lc "sed -n '1,200p' src/tools/gemini_test.ts" in /Users/panda/Desktop/EUFM
[2025-09-03T12:35:59] bash -lc "sed -n '1,200p' src/tools/gemini_test.ts" succeeded in 99ms:
import { geminiComplete } from '../adapters/google_gemini.js';

export async function runGeminiTest(prompt: string): Promise<string> {
	const model = process.env.GEMINI_MODEL || 'gemini-1.5-pro';
	return geminiComplete(prompt, model);
}
[2025-09-03T12:35:59] tokens used: 1695
[2025-09-03T12:35:59] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:36:10] exec bash -lc 'npm run -s typecheck' in /Users/panda/Desktop/EUFM
[2025-09-03T12:36:20] bash -lc 'npm run -s typecheck' succeeded in 8.59s:

[2025-09-03T12:36:20] tokens used: 240
[2025-09-03T12:36:20] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:36:25] exec bash -lc 'npm run -s dev -- orchestrator:analyze "Implement a proactive orchestrator that analyzes tasks, plans agents, and executes in parallel with cost-aware routing."' in /Users/panda/Desktop/EUFM
[2025-09-03T12:36:30] bash -lc 'npm run -s dev -- orchestrator:analyze "Implement a proactive orchestrator that analyzes tasks, plans agents, and executes in parallel with cost-aware routing."' succeeded in 3.63s:
=== Analysis ===
Task: Implement a proactive orchestrator that analyzes tasks, plans agents, and execut
Risk: medium
Requirements:
  - req_1: Implement a proactive orchestrator that analyzes tasks, plans agents, and executes in parallel with cost-aware routing.
    caps=data complexity=medium est=60m

Proactive suggestions:
  - [low] Shift batch workloads to Abacus.ai: You have spare token quota on Abacus.ai; consider shifting batch/offline inference to utilize included capacity.
  - [low] Consider downgrading ChatGPT Plus: You use <20% of the plan limits. A lower tier may suffice.
  - [low] Consider downgrading Claude Pro: You use <20% of the plan limits. A lower tier may suffice.
  - [low] Consider downgrading Perplexity Pro: You use <20% of the plan limits. A lower tier may suffice.
[2025-09-03T12:36:30] tokens used: 188
[2025-09-03T12:36:30] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+


[2025-09-03T12:36:37] thinking

**Testing execution methods**

I'm looking to run a dry test to avoid needing API keys. I've set up the code for StrategicOrchestrator to pass a dryRun parameter when the environment variable DRY_RUN is true. The agents—CodexAgent, JulesAgent, and AbacusAgent—should all implement dryRun correctly. The BrowserAgent doesn't check for dryRun but operates without external calls. MemoryAgent should load its memory smoothly. So, let's execute this with DRY_RUN=true!
[2025-09-03T12:36:40] exec bash -lc 'DRY_RUN=true npm run -s dev -- orchestrator:execute "Build a small feature: add a CLI command that prints hello and write a unit test. Research any best practices. Automate web UI to toggle a setting."' in /Users/panda/Desktop/EUFM
[2025-09-03T12:36:44] bash -lc 'DRY_RUN=true npm run -s dev -- orchestrator:execute "Build a small feature: add a CLI command that prints hello and write a unit test. Research any best practices. Automate web UI to toggle a setting."' succeeded in 3.22s:
=== Execution Result ===
Task: Build a small feature: add a CLI command that prints hello and write a unit test
Started: 2025-09-03T12:36:43.146Z
Finished: 2025-09-03T12:36:43.281Z
Success: true
Results:
  - req_1/agent_req_1_code: ok
  - req_2/agent_req_2_abacus: ok
  - req_3/agent_req_3_browser: ok
  - req_1/agent_req_1_jules: ok
Summary: All agents completed successfully.
Saved to logs/orchestrator/run_task_1756903003232.json
[2025-09-03T12:36:44] tokens used: 442
[2025-09-03T12:36:44] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

[2025-09-03T12:36:47] exec bash -lc "ls -la logs/orchestrator | sed -n '1,200p' && sed -n '1,200p' logs/orchestrator/"'$(ls logs/orchestrator | tail -n1)' in /Users/panda/Desktop/EUFM
[2025-09-03T12:36:49] bash -lc "ls -la logs/orchestrator | sed -n '1,200p' && sed -n '1,200p' logs/orchestrator/"'$(ls logs/orchestrator | tail -n1)' succeeded in 90ms:
total 24
drwxr-xr-x   4 panda  staff   128 Sep  3 15:36 .
drwxr-xr-x  12 panda  staff   384 Sep  3 15:36 ..
-rw-r--r--   1 panda  staff   519 Sep  3 15:36 patterns.json
-rw-r--r--   1 panda  staff  4553 Sep  3 15:36 run_task_1756903003232.json
{
  "taskId": "task_1756903003232",
  "startedAt": "2025-09-03T12:36:43.146Z",
  "finishedAt": "2025-09-03T12:36:43.281Z",
  "plan": {
    "task": {
      "taskId": "task_1756903003232",
      "title": "Build a small feature: add a CLI command that prints hello and write a unit test",
      "original": "Build a small feature: add a CLI command that prints hello and write a unit test. Research any best practices. Automate web UI to toggle a setting.",
      "requirements": [
        {
          "id": "req_1",
          "description": "Build a small feature: add a CLI command that prints hello and write a unit test.",
          "capabilities": [
            "coding"
[2025-09-03T12:36:49] tokens used: 322
[2025-09-03T12:36:49] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+


[2025-09-03T12:36:53] thinking

**Ensuring CLI commands and exports**

Alright, I need to check if we need to ensure exports for orchestrator modules, but maybe it's only necessary if they're used elsewhere. The user mentioned wanting CLI commands to be discoverable in the README. Now that we updated the CLI, I might also need to check the package.json for "scripts" usage. Okay, I noticed that running dev uses tsx. I should make sure new files are compiled, so I’ll view the tsconfig.
[2025-09-03T12:36:56] exec bash -lc 'cat tsconfig.json' in /Users/panda/Desktop/EUFM
[2025-09-03T12:36:58] bash -lc 'cat tsconfig.json' succeeded in 53ms:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}
[2025-09-03T12:36:58] tokens used: 1774
[2025-09-03T12:36:58] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+


[2025-09-03T12:37:13] thinking

I'm considering how to maintain a balance in my writing without exceeding too many lines. It seems important to keep things concise, especially since this change might require some adjustments in my usual style. I'm wondering how to best convey the information while making it clear and straightforward. It’s a bit of a challenge, but I think I can manage it! Let's ensure everything stays focused and easy to read.
[2025-09-03T12:37:17] codex

I’ve scaffolded a proactive Strategic Agent Orchestrator system, wired it into the CLI, and integrated with memory and analytics for resource-aware planning and learning.

**What I Added**
- Orchestrator Core
  - `src/orchestrator/strategicOrchestrator.ts`: Main orchestrator (analyze, plan, execute, optimize, history).
  - `src/orchestrator/taskAnalyzer.ts`: NLP-ish breakdown, capability detection, complexity and resource estimates.
  - `src/orchestrator/capabilityMapper.ts`: Maps requirements to agents using memory + subscriptions.
  - `src/orchestrator/agentFactory.ts`: Spawns agents by spec, manages lifecycle creation.
  - `src/orchestrator/executionCoordinator.ts`: Parallel batches, dependency handling, failure propagation.
  - `src/orchestrator/types.ts`: Shared types for tasks/plans/results.
- Agents
  - `src/agents/baseAgent.ts`: Base API for all agents.
  - `src/agents/codexAgent.ts`: Code tasks via OpenAI/Anthropic/Gemini adapters with model preference.
  - `src/agents/julesAgent.ts`: Gemini Code Assist style review/research.
  - `src/agents/abacusAgent.ts`: Research tasks via Perplexity adapter (simulates Abacus research mode).
  - `src/agents/browserAgent.ts`: Plan-only web automation steps (no driver dependency).
  - `src/agents/memoryAgent.ts`: Knowledge-base lookup and context assembly.
- Intelligence
  - `src/intelligence/patternLearner.ts`: Learns success signals from past runs; persists to `logs/orchestrator/patterns.json`.
  - `src/intelligence/proactiveAdvisor.ts`: Combines analytics optimization with learned patterns for system-wide advice.
- CLI Integration
  - `src/cli/index.ts`:
    - `orchestrator:analyze 'task'`: Show structured requirements + proactive suggestions.
    - `orchestrator:execute 'task'`: Full run (parallel agents, logs, learning).
    - `orchestrator:optimize`: System-level optimization tips (cost, usage, patterns).
    - `orchestrator:history`: Lists past runs and shows the latest summary.

**Key Features Implemented**
- Proactive: Suggests pre-execution optimizations (from task analyzer, learned patterns, and analytics).
- Learning: Captures outcomes in `logs/orchestrator/run_*.json`; updates `patterns.json`.
- Resource-aware: Uses subscriptions and `OptimizationEngine` to shape tool choices and generate cost suggestions.
- Parallel: Executes requirement batches concurrently with simple dependency resolution.
- Resilient: Continues across requirements; stops within a requirement on the first agent failure to limit waste; pattern signals surface retry/backoff needs.
- Cost-optimized: Advisor suggests provider shifts and plan adjustments based on usage history.

**How It Works**
- Analyze → Plan → Execute:
  - Task text → requirements with capabilities, complexity, resource estimates.
  - Capability mapping → agent specs (Codex/Jules/Abacus/Browser/Memory) guided by subscription data.
  - Parallel batches → coordinator runs agents with shared context, collects results.
  - Results + metadata → logs in `logs/orchestrator`, learner updates patterns to influence future advice.

**Run It**
- Analyze only:
  - `npm run dev -- orchestrator:analyze "Your task description"`
- Execute (dry run to avoid API calls):
  - `DRY_RUN=true npm run dev -- orchestrator:execute "Your task description"`
- Execute (real; set keys first):
  - `export OPENAI_API_KEY=... ANTHROPIC_API_KEY=... GEMINI_API_KEY=... PERPLEXITY_API_KEY=...`
  - `npm run dev -- orchestrator:execute "Your task description"`
- Optimizations:
  - `npm run dev -- orchestrator:optimize`
- History:
  - `npm run dev -- orchestrator:history`
- Optional analytics setup/usage:
  - `npm run dev -- analytics:setup`
  - `EUFM_TRACK_USAGE=true` to auto-track LLM usage from adapters

**Notable Paths**
- Logs: `logs/orchestrator/run_*.json`, `logs/orchestrator/patterns.json`
- Analytics: `logs/analytics/usage.json`, `logs/analytics/subscriptions.json`

**Assumptions and Notes**
- Browser automation is plan-only (no dependency on a driver). It outputs a concrete step plan.
- AbacusAgent is mapped to Perplexity API for research; rename or swap adapter later if you add an Abacus SDK.
- Agents respect `DRY_RUN=true` for safe, dependency-free previews.
- Proactive suggestions leverage current subscription defaults; refine plans via `analytics:setup`.
- No unrelated changes were made; build and typecheck pass.

If you want, I can:
- Add simple retry/backoff wrappers around agent runs for resilience.
- Expand capability mapping rules (e.g., model routing by cost/quality per requirement).
- Add minimal unit tests for the orchestrator planning and coordinator batching.
[2025-09-03T12:37:31] tokens used: 1527
[2025-09-03T12:37:31] turn diff:
diff --git a/src/agents/abacusAgent.ts b/src/agents/abacusAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e6b3482c9abc6a24a7ac35a30d9d915c6110936
--- /dev/null
+++ b/src/agents/abacusAgent.ts
@@ -0,0 +1,20 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { runPerplexityTest } from '../tools/perplexity_sonar.js';
+
+export class AbacusAgent extends BaseAgent {
+  get type() { return 'AbacusAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] AbacusAgent would query research models.', startedAt, finishedAt: this.now() };
+      }
+      const out = await runPerplexityTest(`Research: ${opts.input}. Provide sources and a concise synthesis.`);
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/baseAgent.ts b/src/agents/baseAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..42ff8d0ef4a45ab549130ab06884c9b0ad6a5471
--- /dev/null
+++ b/src/agents/baseAgent.ts
@@ -0,0 +1,22 @@
+import { AgentResult } from '../orchestrator/types.js';
+
+export interface AgentContext {
+  workingDir?: string;
+  shared?: Record<string, any>;
+}
+
+export interface AgentRunOptions {
+  input: string;
+  timeoutMs?: number;
+  dryRun?: boolean;
+}
+
+export abstract class BaseAgent {
+  constructor(public id: string, public requirementId: string) {}
+
+  abstract get type(): string;
+  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;
+
+  protected now() { return new Date().toISOString(); }
+}
+
diff --git a/src/agents/browserAgent.ts b/src/agents/browserAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ba81781cde3a8915ddf0f479853ef8163395fcb5
--- /dev/null
+++ b/src/agents/browserAgent.ts
@@ -0,0 +1,24 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+
+export class BrowserAgent extends BaseAgent {
+  get type() { return 'BrowserAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      // We don’t ship a browser driver here; simulate plan-only with actionable steps.
+      const plan = [
+        'Open target tool UI',
+        'Authenticate if needed',
+        'Navigate to required section',
+        'Perform batch actions to minimize navigation',
+        'Export results and store artifact',
+      ];
+      const output = `[Browser plan]\nTask: ${opts.input}\nSteps:\n- ${plan.join('\n- ')}`;
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/codexAgent.ts b/src/agents/codexAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7921d6cc80c959fbc83ae08d99ab916f483a80ab
--- /dev/null
+++ b/src/agents/codexAgent.ts
@@ -0,0 +1,36 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { openaiComplete } from '../adapters/openai.js';
+import { anthropicComplete } from '../adapters/anthropic.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+function pickModel(pref: 'balanced' | 'cost' | 'quality') {
+  if (pref === 'quality') return { provider: 'anthropic', model: 'claude-3-5-sonnet-latest' } as const;
+  if (pref === 'cost') return { provider: 'openai', model: 'gpt-4o-mini' } as const;
+  return { provider: 'openai', model: 'gpt-4o' } as const;
+}
+
+export class CodexAgent extends BaseAgent {
+  get type() { return 'CodexAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] CodexAgent would plan code changes.', startedAt, finishedAt: this.now() };
+      }
+      const pref: 'balanced' | 'cost' | 'quality' = (ctx?.shared?.modelPreference || 'balanced');
+      const { provider, model } = pickModel(pref);
+      let out = '';
+      const prompt = `You are CodexAgent. Task: ${opts.input}\n\nReturn a concise plan and code diffs if applicable.`;
+      if (provider === 'openai') out = await openaiComplete(prompt, { model, temperature: 0.2 });
+      else if (provider === 'anthropic') out = await anthropicComplete(prompt, model);
+      else out = await geminiComplete(prompt, 'gemini-1.5-pro');
+
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/julesAgent.ts b/src/agents/julesAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..45e35612982ac3210d1c1bc6172e1e25fb6822e1
--- /dev/null
+++ b/src/agents/julesAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { geminiComplete } from '../adapters/google_gemini.js';
+
+export class JulesAgent extends BaseAgent {
+  get type() { return 'JulesAgent'; }
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      if (opts.dryRun) {
+        return { agentId: this.id, requirementId: this.requirementId, success: true, output: '[Dry run] JulesAgent would provide code review and suggestions.', startedAt, finishedAt: this.now() };
+      }
+      const role = ctx?.shared?.role || 'review';
+      const prompt = `You are Jules (Gemini Code Assist). Role: ${role}. Task: ${opts.input}. Provide succinct guidance and actionable steps.`;
+      const out = await geminiComplete(prompt, 'gemini-1.5-pro');
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output: out, startedAt, finishedAt: this.now() };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/agents/memoryAgent.ts b/src/agents/memoryAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f75fc2fc67b89ef89edb761f754778703eb28091
--- /dev/null
+++ b/src/agents/memoryAgent.ts
@@ -0,0 +1,22 @@
+import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
+import { AgentResult } from '../orchestrator/types.js';
+import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/memoryLoader.js';
+
+export class MemoryAgent extends BaseAgent {
+  get type() { return 'MemoryAgent'; }
+  async run(opts: AgentRunOptions, _ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const notes = await loadKnowledgeBase();
+      const results = findNotesByQuery(notes, opts.input);
+      const context = toContext(results, { maxBytes: 8000 });
+      const output = results.length
+        ? `Found ${results.length} related notes. Context preview:\n\n${context}`
+        : 'No direct matches in knowledge base.';
+      return { agentId: this.id, requirementId: this.requirementId, success: true, output, startedAt, finishedAt: this.now(), artifacts: { matched: results.map(r => ({ path: r.path, title: r.title })) } };
+    } catch (e: any) {
+      return { agentId: this.id, requirementId: this.requirementId, success: false, output: '', error: e?.message || String(e), startedAt, finishedAt: this.now() };
+    }
+  }
+}
+
diff --git a/src/cli/index.ts b/src/cli/index.ts
index fbe53b8aaa4d899af59847aee1fdbc5c97d235c9..ea393522150c26464d9d82de34f0d2e192cb388e
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -3,6 +3,7 @@
 import { runGeminiTest } from '../tools/gemini_test.js';
 import { loadKnowledgeBase, toContext, findNotesByQuery } from '../memory/index.js';
 import { UsageAnalyticsAgent } from '../analytics/usageAnalytics.js';
+import { StrategicOrchestrator } from '../orchestrator/strategicOrchestrator.js';
 
 async function main() {
 	const cmd = process.argv[2] || 'help';
@@ -77,6 +78,65 @@
 			break;
 		}
 
+		case 'orchestrator:analyze': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:analyze "task description"'); break; }
+			const orch = new StrategicOrchestrator();
+			const { analyzed, suggestions } = await orch.analyze(task);
+			console.log('=== Analysis ===');
+			console.log(`Task: ${analyzed.title}`);
+			console.log(`Risk: ${analyzed.riskLevel}`);
+			console.log('Requirements:');
+			for (const r of analyzed.requirements) {
+				console.log(`  - ${r.id}: ${r.description}`);
+				console.log(`    caps=${r.capabilities.join(', ')} complexity=${r.estimatedComplexity} est=${r.estimatedResources.timeMinutes}m`);
+				if (r.optimizations?.length) console.log(`    optimizations: ${r.optimizations.join('; ')}`);
+			}
+			if (suggestions.length) {
+				console.log('\nProactive suggestions:');
+				suggestions.forEach((s) => console.log(`  - ${s}`));
+			}
+			break;
+		}
+
+		case 'orchestrator:execute': {
+			const task = process.argv.slice(3).join(' ');
+			if (!task) { console.log('Usage: npm run dev -- orchestrator:execute "task description"'); break; }
+			const dry = String(process.env.DRY_RUN || '').toLowerCase() === 'true';
+			const orch = new StrategicOrchestrator();
+			const run = await orch.execute(task, { dryRun: dry });
+			console.log('=== Execution Result ===');
+			console.log(`Task: ${run.plan.task.title}`);
+			console.log(`Started: ${run.startedAt}`);
+			console.log(`Finished: ${run.finishedAt}`);
+			console.log(`Success: ${run.success}`);
+			console.log('Results:');
+			for (const r of run.results) {
+				console.log(`  - ${r.requirementId}/${r.agentId}: ${r.success ? 'ok' : 'fail'}${r.error ? ` (${r.error})` : ''}`);
+			}
+			console.log(`Summary: ${run.summary}`);
+			console.log(`Saved to logs/orchestrator/run_${run.taskId}.json`);
+			break;
+		}
+
+		case 'orchestrator:optimize': {
+			const orch = new StrategicOrchestrator();
+			const suggestions = await orch.optimize();
+			console.log('=== Orchestrator Optimization ===');
+			if (!suggestions.length) console.log('No suggestions at this time.');
+			for (const s of suggestions) console.log(`- ${s}`);
+			break;
+		}
+
+		case 'orchestrator:history': {
+			const orch = new StrategicOrchestrator();
+			const h = await orch.history();
+			console.log('=== Orchestrator History ===');
+			console.log(`Runs: ${h.files.length}`);
+			if (h.latest) console.log(`Latest: ${h.latest.taskId} (${h.latest.startedAt} -> ${h.latest.finishedAt}) success=${h.latest.success}`);
+			break;
+		}
+
 		default:
 			console.log('Usage:');
 			console.log('  npm run dev -- perplexity:test "your prompt"');
@@ -84,6 +144,10 @@
 			console.log('  npm run dev -- memory:load');
 			console.log('  npm run dev -- memory:context');
 			console.log('  npm run dev -- memory:search "query"');
+			console.log('  npm run dev -- orchestrator:analyze "task"');
+			console.log('  npm run dev -- orchestrator:execute "task"');
+			console.log('  npm run dev -- orchestrator:optimize');
+			console.log('  npm run dev -- orchestrator:history');
 	}
 }
 
diff --git a/src/intelligence/patternLearner.ts b/src/intelligence/patternLearner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cbc9af5c218fa3b95a492f8d5b7f19c10b78060a
--- /dev/null
+++ b/src/intelligence/patternLearner.ts
@@ -0,0 +1,63 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { AgentResult, OrchestrationResult } from '../orchestrator/types.js';
+
+export interface LearnedPattern {
+  id: string;
+  description: string;
+  signals: string[];
+  effectiveness: number; // 0..1
+  lastUpdated: string;
+}
+
+export class PatternLearner {
+  constructor(private baseDir = 'logs/orchestrator') {}
+
+  private patternsPath() { return path.join(this.baseDir, 'patterns.json'); }
+
+  private async load(): Promise<LearnedPattern[]> {
+    try {
+      const txt = await fs.readFile(this.patternsPath(), 'utf8');
+      const arr = JSON.parse(txt);
+      return Array.isArray(arr) ? arr : [];
+    } catch { return []; }
+  }
+
+  private async save(all: LearnedPattern[]) {
+    await fs.mkdir(this.baseDir, { recursive: true });
+    await fs.writeFile(this.patternsPath(), JSON.stringify(all, null, 2), 'utf8');
+  }
+
+  async updateFromRun(run: OrchestrationResult): Promise<void> {
+    const all = await this.load();
+    // Very simple heuristic: reward agent combos that succeeded, penalize those that failed
+    const groups: Record<string, { success: number; total: number; signals: Set<string> }> = {};
+    for (const r of run.results) {
+      const key = `${r.requirementId}`;
+      if (!groups[key]) groups[key] = { success: 0, total: 0, signals: new Set() };
+      groups[key].total += 1;
+      if (r.success) groups[key].success += 1;
+      // derive signals from content
+      const content = `${r.output} ${r.error ?? ''}`.toLowerCase();
+      if (/test|unit|spec/.test(content)) groups[key].signals.add('tests-helped');
+      if (/timeout|rate limit|quota/.test(content)) groups[key].signals.add('needs-retry-with-backoff');
+      if (/browser|navigate/.test(content)) groups[key].signals.add('browser-automation-applicable');
+    }
+    const now = new Date().toISOString();
+    for (const [key, g] of Object.entries(groups)) {
+      const eff = g.total ? g.success / g.total : 0;
+      const existing = all.find((p) => p.id === key);
+      if (existing) {
+        existing.effectiveness = Math.round((existing.effectiveness * 0.7 + eff * 0.3) * 100) / 100;
+        existing.signals = Array.from(new Set([...existing.signals, ...Array.from(g.signals)]));
+        existing.lastUpdated = now;
+      } else {
+        all.push({ id: key, description: `Patterns for ${key}`, signals: Array.from(g.signals), effectiveness: eff, lastUpdated: now });
+      }
+    }
+    await this.save(all);
+  }
+
+  async list(): Promise<LearnedPattern[]> { return this.load(); }
+}
+
diff --git a/src/intelligence/proactiveAdvisor.ts b/src/intelligence/proactiveAdvisor.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eb78d513a92a39eae7b88bae7bf43c96ac3509d8
--- /dev/null
+++ b/src/intelligence/proactiveAdvisor.ts
@@ -0,0 +1,38 @@
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { LearnedPattern, PatternLearner } from './patternLearner.js';
+
+export interface AdvisoryReport {
+  systemSuggestions: string[];
+  learnedPatterns: LearnedPattern[];
+}
+
+export class ProactiveAdvisor {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+  learner = new PatternLearner();
+
+  async advise(): Promise<AdvisoryReport> {
+    const events = await this.tracker.list();
+    const report = await this.engine.buildReport(events);
+    const learned = await this.learner.list();
+    const sys: string[] = [];
+
+    // Convert optimization suggestions to simple text advice
+    for (const s of report.suggestions) sys.push(`[${s.impact}] ${s.title}: ${s.details}${s.action ? ` | Action: ${s.action}` : ''}`);
+
+    // Meta-suggestions based on learned patterns
+    for (const p of learned) {
+      if (p.signals.includes('needs-retry-with-backoff')) sys.push('Enable exponential backoff and jitter for API retries to reduce failures.');
+      if (p.signals.includes('tests-helped')) sys.push('Automatically scaffold minimal tests for coding tasks to reduce regressions.');
+      if (p.signals.includes('browser-automation-applicable')) sys.push('Bundle browser steps and cache sessions to reduce logins.');
+    }
+
+    // De-duplicate
+    const deduped = Array.from(new Set(sys));
+    return { systemSuggestions: deduped, learnedPatterns: learned };
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1683dc4a527215a8f692b0d0481116c4f83715df
--- /dev/null
+++ b/src/orchestrator/agentFactory.ts
@@ -0,0 +1,23 @@
+import { AgentSpec } from './types.js';
+import { BaseAgent } from '../agents/baseAgent.js';
+import { CodexAgent } from '../agents/codexAgent.js';
+import { JulesAgent } from '../agents/julesAgent.js';
+import { AbacusAgent } from '../agents/abacusAgent.js';
+import { BrowserAgent } from '../agents/browserAgent.js';
+import { MemoryAgent } from '../agents/memoryAgent.js';
+
+export class AgentFactory {
+  create(spec: AgentSpec): BaseAgent {
+    const { id, type, requirementId } = spec;
+    switch (type) {
+      case 'CodexAgent': return new CodexAgent(id, requirementId);
+      case 'JulesAgent': return new JulesAgent(id, requirementId);
+      case 'AbacusAgent': return new AbacusAgent(id, requirementId);
+      case 'BrowserAgent': return new BrowserAgent(id, requirementId);
+      case 'MemoryAgent': return new MemoryAgent(id, requirementId);
+      default:
+        throw new Error(`Unknown agent type: ${type}`);
+    }
+  }
+}
+
diff --git a/src/orchestrator/capabilityMapper.ts b/src/orchestrator/capabilityMapper.ts
new file mode 100644
index 0000000000000000000000000000000000000000..132c5f7082005757158dc1b73516ce2c0df88486
--- /dev/null
+++ b/src/orchestrator/capabilityMapper.ts
@@ -0,0 +1,59 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { OptimizationEngine } from '../analytics/optimizationEngine.js';
+import { SubscriptionManager, FileSubscriptionStore } from '../analytics/subscriptionManager.js';
+import { ToolUsageTracker } from '../analytics/toolUsageTracker.js';
+import { AgentSpec } from './types.js';
+
+export class CapabilityMapper {
+  subs = new SubscriptionManager(new FileSubscriptionStore('logs/analytics/subscriptions.json'));
+  tracker = new ToolUsageTracker();
+  engine = new OptimizationEngine(this.subs, this.tracker);
+
+  async map(requirementId: string, description: string, capabilities: string[]): Promise<AgentSpec[]> {
+    const specs: AgentSpec[] = [];
+    const caps = new Set(capabilities);
+    const subs = await this.subs.getSubscriptions();
+
+    // Memory-aware routing
+    try {
+      const kb = await loadKnowledgeBase();
+      const isDocHeavy = kb.length > 0 && /docs|readme|kb|knowledge|architecture/i.test(description);
+      if (isDocHeavy) {
+        specs.push({ id: `agent_${requirementId}_mem`, type: 'MemoryAgent', requirementId, capabilities: ['memory'], params: { query: description } });
+      }
+    } catch {}
+
+    // Coding
+    if (caps.has('coding')) {
+      // Prefer local CodexAgent abstraction (wraps OpenAI/Anthropic/Gemini via adapters), fallbacks based on subscription cost-awareness
+      specs.push({ id: `agent_${requirementId}_code`, type: 'CodexAgent', requirementId, capabilities: ['coding'], params: { modelPreference: 'balanced' } });
+      // Secondary advisor using Gemini for code review if available
+      specs.push({ id: `agent_${requirementId}_jules`, type: 'JulesAgent', requirementId, capabilities: ['coding'], params: { role: 'review' } });
+    }
+
+    // Research
+    if (caps.has('research')) {
+      // Prefer Perplexity for web research if PRO plan
+      const usePerplexity = subs.perplexity === 'perplexity_pro';
+      if (usePerplexity) {
+        specs.push({ id: `agent_${requirementId}_abacus`, type: 'AbacusAgent', requirementId, capabilities: ['research'], params: { mode: 'research' } });
+      } else {
+        // Fall back to Gemini/Claude via JulesAgent for general research
+        specs.push({ id: `agent_${requirementId}_jules_research`, type: 'JulesAgent', requirementId, capabilities: ['research'], params: { role: 'research' } });
+      }
+    }
+
+    // Data
+    if (caps.has('data')) {
+      specs.push({ id: `agent_${requirementId}_code_data`, type: 'CodexAgent', requirementId, capabilities: ['data', 'coding'], params: { modelPreference: 'cost' } });
+    }
+
+    // Web automation
+    if (caps.has('web_automation')) {
+      specs.push({ id: `agent_${requirementId}_browser`, type: 'BrowserAgent', requirementId, capabilities: ['web_automation'], params: { headless: true } });
+    }
+
+    return specs;
+  }
+}
+
diff --git a/src/orchestrator/executionCoordinator.ts b/src/orchestrator/executionCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..81837be13d4e484186db6f34ba36b38fd8cae84d
--- /dev/null
+++ b/src/orchestrator/executionCoordinator.ts
@@ -0,0 +1,50 @@
+import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
+import { AgentFactory } from './agentFactory.js';
+
+export interface ExecutionOptions {
+  dryRun?: boolean;
+  timeoutMs?: number;
+  concurrency?: number; // max agents in parallel
+}
+
+export class ExecutionCoordinator {
+  private factory = new AgentFactory();
+
+  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
+    const results: AgentResult[] = [];
+    const ctxShared: Record<string, any> = {};
+    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);
+
+    for (const batch of plan.parallelBatches) {
+      // Throttle within batch to configured concurrency
+      const queue = [...batch];
+      const active: Promise<void>[] = [];
+      const runOne = async (reqId: string) => {
+        const specs = plan.agentSpecs.filter((a) => a.requirementId === reqId);
+        for (const spec of specs) {
+          const agent = this.factory.create(spec);
+          const out = await agent.run({ input: inputByReq[reqId], timeoutMs: options.timeoutMs, dryRun: options.dryRun }, { shared: { ...ctxShared, ...(spec.params || {}) } });
+          results.push(out);
+          // Simple knowledge sharing: stash outputs by requirement
+          ctxShared[`out_${reqId}_${spec.type}`] = out.output;
+          if (!out.success) break; // leave early if agent in this requirement failed
+        }
+      };
+
+      while (queue.length > 0 || active.length > 0) {
+        while (active.length < concurrency && queue.length > 0) {
+          const reqId = queue.shift()!;
+          const p = runOne(reqId).finally(() => {
+            const i = active.indexOf(p as any);
+            if (i >= 0) active.splice(i, 1);
+          });
+          active.push(p as any);
+        }
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    return results;
+  }
+}
+
diff --git a/src/orchestrator/strategicOrchestrator.ts b/src/orchestrator/strategicOrchestrator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f3347f09d3b1faa2de6136e73cdc450c5a56b1e9
--- /dev/null
+++ b/src/orchestrator/strategicOrchestrator.ts
@@ -0,0 +1,98 @@
+import { promises as fs } from 'fs';
+import path from 'path';
+import { TaskAnalyzer } from './taskAnalyzer.js';
+import { CapabilityMapper } from './capabilityMapper.js';
+import { ExecutionCoordinator } from './executionCoordinator.js';
+import { PatternLearner } from '../intelligence/patternLearner.js';
+import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
+import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';
+
+export class StrategicOrchestrator {
+  private analyzer = new TaskAnalyzer();
+  private mapper = new CapabilityMapper();
+  private coordinator = new ExecutionCoordinator();
+  private learner = new PatternLearner();
+  private advisor = new ProactiveAdvisor();
+  private baseDir = 'logs/orchestrator';
+
+  private async saveJson(rel: string, data: any) {
+    const out = path.join(this.baseDir, rel);
+    await fs.mkdir(path.dirname(out), { recursive: true });
+    await fs.writeFile(out, JSON.stringify(data, null, 2), 'utf8');
+  }
+
+  private async listRuns(): Promise<string[]> {
+    try { return (await fs.readdir(this.baseDir)).filter((f) => f.startsWith('run_') && f.endsWith('.json')); } catch { return []; }
+  }
+
+  async analyze(task: string): Promise<{ analyzed: AnalyzedTask; suggestions: string[] }> {
+    const analyzed = await this.analyzer.analyze(task);
+    const suggestions: string[] = [];
+    // Proactive advice
+    try {
+      const adv = await this.advisor.advise();
+      suggestions.push(...adv.systemSuggestions);
+    } catch {}
+    // Requirement-level suggestions
+    for (const r of analyzed.requirements) suggestions.push(...(r.optimizations || []));
+    return { analyzed, suggestions: Array.from(new Set(suggestions)) };
+  }
+
+  async plan(analyzed: AnalyzedTask): Promise<OrchestrationPlan> {
+    const agentSpecs = (
+      await Promise.all(
+        analyzed.requirements.map((r) => this.mapper.map(r.id, r.description, r.capabilities))
+      )
+    ).flat();
+    // batch by simple dependency: requirements with no deps in batch 1, etc.
+    const idToDeps = new Map(analyzed.requirements.map((r) => [r.id, new Set(r.dependencies || [])]));
+    const remaining = new Set(analyzed.requirements.map((r) => r.id));
+    const batches: string[][] = [];
+    while (remaining.size) {
+      const ready: string[] = [];
+      for (const id of Array.from(remaining)) {
+        const deps = idToDeps.get(id)!;
+        if (Array.from(deps).every((d) => !remaining.has(d))) ready.push(id);
+      }
+      if (ready.length === 0) { // break circular deps
+        ready.push(...Array.from(remaining));
+      }
+      batches.push(ready);
+      ready.forEach((r) => remaining.delete(r));
+    }
+    const suggestions: string[] = analyzed.notes ? [...analyzed.notes] : [];
+    return { task: analyzed, agentSpecs, parallelBatches: batches, suggestions };
+  }
+
+  async execute(taskText: string, opts: { dryRun?: boolean } = {}): Promise<OrchestrationResult> {
+    const startedAt = new Date().toISOString();
+    const { analyzed } = await this.analyze(taskText);
+    const plan = await this.plan(analyzed);
+    const inputByReq = Object.fromEntries(plan.task.requirements.map((r) => [r.id, r.description]));
+    const results = await this.coordinator.execute(plan, inputByReq, { dryRun: opts.dryRun, concurrency: plan.task.requirements.length });
+    const success = results.every((r) => r.success);
+    const finishedAt = new Date().toISOString();
+    const summary = success ? 'All agents completed successfully.' : 'Some agents failed; review errors.';
+    const run: OrchestrationResult = { taskId: plan.task.taskId, startedAt, finishedAt, plan, results, success, summary };
+
+    await this.saveJson(`run_${plan.task.taskId}.json`, run);
+    await this.learner.updateFromRun(run).catch(() => {});
+    return run;
+  }
+
+  async optimize(): Promise<string[]> {
+    const adv = await this.advisor.advise();
+    return adv.systemSuggestions;
+  }
+
+  async history(): Promise<{ files: string[]; latest?: OrchestrationResult }> {
+    const files = (await this.listRuns()).sort();
+    let latest: OrchestrationResult | undefined;
+    if (files.length) {
+      const txt = await fs.readFile(path.join(this.baseDir, files[files.length - 1]), 'utf8');
+      latest = JSON.parse(txt);
+    }
+    return { files, latest };
+  }
+}
+
diff --git a/src/orchestrator/taskAnalyzer.ts b/src/orchestrator/taskAnalyzer.ts
new file mode 100644
index 0000000000000000000000000000000000000000..469cd10fcd951cd8a8661b40bdaf68d040c749e9
--- /dev/null
+++ b/src/orchestrator/taskAnalyzer.ts
@@ -0,0 +1,118 @@
+import { loadKnowledgeBase } from '../memory/memoryLoader.js';
+import { AnalyzedTask, Capability, TaskRequirement } from './types.js';
+
+function detectCapabilities(text: string): Capability[] {
+  const t = text.toLowerCase();
+  const caps = new Set<Capability>();
+  if (/(code|typescript|js|python|bug|refactor|build|test)/.test(t)) caps.add('coding');
+  if (/(research|compare|summarize|investigate|find sources|benchmark)/.test(t)) caps.add('research');
+  if (/(data|csv|json|analy[sz]e|report|chart|metrics)/.test(t)) caps.add('data');
+  if (/(browser|web ui|automation|scrape|navigate|click|form)/.test(t)) caps.add('web_automation');
+  if (/(memory|kb|docs|knowledge base|context)/.test(t)) caps.add('memory');
+  // Defaults: if nothing matched, infer based on verbs
+  if (caps.size === 0) caps.add('research');
+  return Array.from(caps);
+}
+
+function estimateComplexity(text: string): 'low' | 'medium' | 'high' {
+  const len = text.length;
+  const signals = [
+    /(multi[- ]?step|complex|architecture|orchestrator|framework)/i,
+    /(deadline|mission[- ]critical|production)/i,
+    /(integrate|refactor|migrate|optimi[sz]e)/i,
+  ].reduce((acc, rx) => acc + (rx.test(text) ? 1 : 0), 0);
+  if (signals >= 2 || len > 800) return 'high';
+  if (signals >= 1 || len > 300) return 'medium';
+  return 'low';
+}
+
+function estimateResources(capabilities: Capability[], complexity: 'low' | 'medium' | 'high') {
+  const base = complexity === 'high' ? 180 : complexity === 'medium' ? 60 : 20;
+  const tokens = complexity === 'high' ? 500_000 : complexity === 'medium' ? 150_000 : 50_000;
+  const concurrency = Math.min(4, 1 + Math.floor(capabilities.length / 2));
+  return { timeMinutes: base, tokens, concurrency };
+}
+
+function splitIntoRequirements(text: string, capabilities: Capability[]): TaskRequirement[] {
+  // Heuristic split by sentences and capabilities; in practice this would use a model.
+  const sentences = text
+    .split(/\n+|(?<=[.!?])\s+/)
+    .map((s) => s.trim())
+    .filter(Boolean);
+  const reqs: TaskRequirement[] = [];
+  let idx = 0;
+  for (const s of sentences) {
+    const caps = detectCapabilities(s).filter((c) => capabilities.includes(c));
+    if (!caps.length) continue;
+    const complexity = estimateComplexity(s);
+    reqs.push({
+      id: `req_${++idx}`,
+      description: s,
+      capabilities: caps,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(caps, complexity),
+      dependencies: [],
+      priority: complexity === 'high' ? 1 : complexity === 'medium' ? 2 : 3,
+      optimizations: [],
+    });
+  }
+  if (reqs.length === 0) {
+    const complexity = estimateComplexity(text);
+    reqs.push({
+      id: `req_1`,
+      description: text,
+      capabilities,
+      estimatedComplexity: complexity,
+      estimatedResources: estimateResources(capabilities, complexity),
+      dependencies: [],
+      priority: 2,
+      optimizations: [],
+    });
+  }
+  // Simple dependency inference: if a requirement mentions "before/first", push it earlier
+  const firstIdx = reqs.findIndex((r) => /before|first|setup/i.test(r.description));
+  if (firstIdx > 0) {
+    const [first] = reqs.splice(firstIdx, 1);
+    reqs.unshift(first);
+    for (let i = 1; i < reqs.length; i++) reqs[i].dependencies?.push(first.id);
+  }
+  return reqs;
+}
+
+export class TaskAnalyzer {
+  async analyze(taskText: string): Promise<AnalyzedTask> {
+    const title = taskText.split(/\n/)[0].slice(0, 80);
+    const caps = detectCapabilities(taskText);
+    const complexity = estimateComplexity(taskText);
+    const notes: string[] = [];
+
+    // Use knowledge base to suggest potential links or existing context
+    try {
+      const kb = await loadKnowledgeBase();
+      const related = kb.filter((n) => {
+        const q = title.toLowerCase();
+        return n.title.toLowerCase().includes(q) || n.content.toLowerCase().includes(q);
+      });
+      if (related.length) notes.push(`Found ${related.length} related notes in knowledge base.`);
+    } catch {}
+
+    const requirements = splitIntoRequirements(taskText, caps);
+
+    // Pre-execution optimizations
+    for (const r of requirements) {
+      if (r.capabilities.includes('coding')) r.optimizations?.push('Add unit tests for critical paths');
+      if (r.capabilities.includes('research')) r.optimizations?.push('Use cached knowledge base context to reduce API calls');
+      if (r.capabilities.includes('web_automation')) r.optimizations?.push('Batch browser actions to minimize navigation');
+    }
+
+    return {
+      taskId: `task_${Date.now()}`,
+      title,
+      original: taskText,
+      requirements,
+      riskLevel: complexity,
+      notes,
+    };
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c7d0a1536e06529d165f5e0bb9a6618fa6b7558
--- /dev/null
+++ b/src/orchestrator/types.ts
@@ -0,0 +1,64 @@
+export type Capability = 'coding' | 'research' | 'data' | 'web_automation' | 'memory';
+
+export interface TaskRequirement {
+  id: string;
+  description: string;
+  capabilities: Capability[];
+  dependencies?: string[];
+  priority?: number;
+  estimatedComplexity: 'low' | 'medium' | 'high';
+  estimatedResources: {
+    timeMinutes: number;
+    tokens?: number;
+    concurrency?: number;
+  };
+  optimizations?: string[];
+}
+
+export interface AnalyzedTask {
+  taskId: string;
+  title: string;
+  original: string;
+  requirements: TaskRequirement[];
+  riskLevel: 'low' | 'medium' | 'high';
+  notes?: string[];
+}
+
+export interface AgentSpec {
+  id: string;
+  type: 'CodexAgent' | 'JulesAgent' | 'AbacusAgent' | 'BrowserAgent' | 'MemoryAgent';
+  requirementId: string;
+  capabilities: Capability[];
+  params?: Record<string, any>;
+}
+
+export interface AgentResult {
+  agentId: string;
+  requirementId: string;
+  success: boolean;
+  output: string;
+  artifacts?: Record<string, any>;
+  costUSD?: number;
+  startedAt: string;
+  finishedAt: string;
+  retries?: number;
+  error?: string;
+}
+
+export interface OrchestrationPlan {
+  task: AnalyzedTask;
+  agentSpecs: AgentSpec[];
+  parallelBatches: string[][]; // batches of requirementIds to run in parallel
+  suggestions: string[];
+}
+
+export interface OrchestrationResult {
+  taskId: string;
+  startedAt: string;
+  finishedAt: string;
+  plan: OrchestrationPlan;
+  results: AgentResult[];
+  success: boolean;
+  summary: string;
+}
+

